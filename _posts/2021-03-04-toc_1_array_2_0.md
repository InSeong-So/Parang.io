---
title: "더블링(Doubling of Array)"
excerpt: "더블링(Doubling of Array)"

categories:
  - IT-Note
tags:
  - 자료구조, 배열, 개념, 더블링, 분할 상환 분석
last_modified_at: 2021-03-04T07:24:37-05:00
---

## 참조

- 사이트
    - [블로그](https://blog.naver.com/manonflame/220900695246)
- 개념

    [분할 상환 분석(Amortized Analysis)](https://inseong-so.github.io/it-note/toc_1_array_2_1/)

## 개념

- 정보가 많아 해당 배열에 데이터를 모두 담지 못할 때, 두 배 큰 배열을 만들어 기존의 배열에서 데이터를 모두 옮기기까지의 작업이다.

### 장점

- 유연한 메모리의 사용량으로 배열을 구현할 수 있다.

### 단점

- 더블링 연산을 할 때마다 비용이 든다.

## 비용

- 크기 n의 배열에 n+1번째 요소가 삽입되는 상황이다.
    - n+1번째 요소가 추가 될 때의 비용
        - `t`
    - n번째 요소까지 전송(Transferring)하는 비용
        - `n * t`
    - n번째 요소까지 추가되면서 들어간 비용
        - `(t / 2) * n + (t / 4) * n + (t / 8) * n + ... <= t * n`
    - 즉, 크기 n의 배열에 n + 1번째 요소가 삽입될 때의 계산량은 `2t * n`이다.

## 확장

### 우리가 알고 있는 것

- 위의 결과를 바탕으로 분할 상환 분석에 적용해보자. 동적 배열의 경우 특정 시점에 더 많은 연산량을 소비하므로 알고리즘의 비용을 계산할 때 "최악의 경우"만을 상정하는 건 맞지 않다.
    - 이러한 특정 시점의 발생을 예상하여 해당 연산량은 나누어 분산시키는 것이 분할 상환 분석의 핵심이다.
- `Amortized cost = Actual cost + Accounting cost`
    - Actual cost : 매 알고리즘 당 실제로 들어가는 비용
    - Accounting cost : "특정 시점의 연산량"을 대비해 미리 쌓아두는 비용
- n + 1번째 상황만 고려해보자.
    - n개의 요소가 있는 배열에 n + 1번째 요소가 삽입될 때의 비용
        - 데이터를 n개 넣을 때 까지는 더블링 연산이 없는 것으로 가정한다.
        - n개의 데이터를 전송하는 비용
            - `tn`
        - $n+1$번째 요소에 데이터 삽입
            - 1
        - n번째 요소까지 추가되면서 들어간 비용
            - n
        - 여기까지 비용은 `tn + 1 + n`인데, 이 연산이 일어날 확률은 n + 1번째 요소를 넣을 때 한 번 일어나므로 최악의 경우의 평균 연산은 `(tn + 1 + n) / (n + 1)`이 된다.
- 동적 배열에서 일반적인 경우(Actual Cost)의 데이터 삽입 비용은 `1`이나 최악의 경우(Worst Cost)의 데이터 삽입 비용은 `(tn + 1 + n) / (n+1) ≓ t`이 되는 것이다.

### 하지만?

- 위의 값을 그냥 더해서는 2n + 1번째 요소에 데이터를 삽입하는 상황인 다음 더블링의 직접 비용이 음수가 된다.
    - 현재까지는 n + 1번째 요소에 데이터를 넣을 때의 더블링만 추가한 것이다.
    - 즉 n개의 데이터를 넣을 때까지의 더블링 비용이 고려되지 않은 것이다.
- 이전의 더블링 및 전송 비용을 합하여 약 `2t * n`이라는 것을 알았으므로 Accounting cost 값은 `2t`이며 Amortized cost 는 `1 + 2t`이다.
    - 더블링이 비용을 대비해 데이터를 삽입하여 그 비용을 조금씩 나누어 지불하는 개념이다.
- 일반적인 경우 필요한 비용보다 더 많은 비용이 든다고 계산한다는 말인데, 남는 비용을 잔여금이라고 하고, 잔여금의 총합을 적립금이라고 하자.
    - n + 1번째 요소에 데이터 삽입 시 n번째까지의 잔여금(적립금)의 비용
        - `n * (1 + 2t) - n = 2tn`
    - n+1번째 요소에 데이터 삽입 시 해당 비용과 더블링에 따른 추가 비용
        - `(1 + 2t) - (tn - 1) = 2t - tn`
    - 따라서,  잔여금은 `2t + tn`이 된다.
- 그렇다면 2n + 1번째 요소에 데이터가 삽입될 때는?
    - 2n번째까지의 잔여금 즉, 적립금 - 비용 = 잔여금
        - `(n - 1)(1 + 2t) - (n + 1) = 2tn - 2t`
        - ⭐️여기서 n - 1로 계산하는 이유는 우리가 n + 1까지는 비용 계산을 했기 때문이다.
    - 2n + 1번째 요소에 데이터 삽입 시 해당 비용과 더블링에 따른 추가 비용
        - `(1 + 2t) -(2t + 1) = -2tn + 2t`
    - 따라서, 잔여금은 `2t + tn`이 된다.
- 결국 더블링에 따른 추가 비용이 발생 했을 때에 남는 잔여금은 `2t + tn`으로 동일하므로 **귀납 증명이 가능**하다.

## 결론

- Array Doubling을 통해서 구현한 스택의 push연산은 한 번에 Amortized of 1의 복잡도로 수행된다.