---
title: "연결 리스트(Linked List)"
excerpt: "연결 리스트(Linked List)"

categories:
  - IT-Note
tags:
  - 자료구조, 배열, 개념, 연결 리스트
last_modified_at: 2021-04-25T22:44:37
---

## 참조

- 블로그
    - [https://www.holaxprogramming.com/2014/02/12/java-list-interface/](https://www.holaxprogramming.com/2014/02/12/java-list-interface/)
    - [생활코딩](https://opentutorials.org/module/1335/8821)
- 개념

    [배열 리스트(Array List)](%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%20%E1%84%85%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3(Array%20List)%20311013d3791c464fa058ac9a1f31ff08.md)

## 용어

- 노드 & 버텍스
    - 엘리먼트가 연결되어 있다는 특성을 가지므로 Node 또는 Vertext라고 표현
    - 노드는 마디, 교점이며 버텍스는 정점, 꼭지점이다.
- 구조체(필드)
- 헤드

## 의미

연결 리스트(LinkedList)는 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식의 자료구조이다.

데이터를 담고 있는 노드들이 연결되어 있고, 노드의 포인터가 이전 노드와 다음 노드와의 연결을 담당한다. 중간에 데이터를 추가하거나 삭제하면 노드는 객체의 앞 뒤 링크만 변경한다.

이처럼 전체의 인덱스가 한 칸씩 뒤로 밀리거나 당겨지는 일이 없기에 배열 리스트(ArrayList)에 비해서 데이터의 추가나 삭제가 용이하나, 인덱스가 없어 특정 요소에 접근하기 위해서는 순차 탐색이 필요하다.

탐색 또는 정렬을 자주 하는 경우엔 배열을 사용하고 데이터의 추가/삭제가 많은 경우 연결 리스트를 사용하는 것이 좋다.

![https://blog.kakaocdn.net/dn/bqsySc/btqEk1stewE/tnty2kV69c7l45eyUO3Jh0/img.png](https://blog.kakaocdn.net/dn/bqsySc/btqEk1stewE/tnty2kV69c7l45eyUO3Jh0/img.png)

ArrayList는 내부 배열에 객체를 저장해서 인덱스로 관리하는데 비해서 LinkedList는 위와 같이 인접 참조를 링크해서 체인처럼 관리한다.

## ArrayList와 LinkedList의 차이점

### ArrayList : 엘리먼트들이 메모리 상에 연속되어 있다.

ArrayList는 데이터의 추가, 삭제를 위해 [더블링](%E1%84%83%E1%85%A5%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC(Doubling%20of%20Array)%200805ac4302fd48479c70c21bd26ce596.md)으로 임시 배열을 생성하고 데이터를 복사한다.

[https://lh5.googleusercontent.com/7pSzmL9zBHuRuDAbWV6NjmYEx2otpkTVCA5aStNUESja4KAhPCllb8Dc277BRSaLEmy4Q-y1GS2X5WwLtylnxWo3q4CkcJRo4DA9PEesAX04HEZmaL9pOIqvlyQ8fWakBg](https://lh5.googleusercontent.com/7pSzmL9zBHuRuDAbWV6NjmYEx2otpkTVCA5aStNUESja4KAhPCllb8Dc277BRSaLEmy4Q-y1GS2X5WwLtylnxWo3q4CkcJRo4DA9PEesAX04HEZmaL9pOIqvlyQ8fWakBg)

대량의 자료를 추가 또는 삭제 하는 경우에는 그만큼 데이터의 복사가 많이 일어나게 되어 성능 저하를 일으킬 수 있다. 반면 ***각 데이터는 인덱스를 가지고 있기 때문에 한번에 참조가 가능해 데이터의 검색에는 유리한 구현체***이다.

### LinkedList : 엘리먼트들이 메모리에 흩어져 있으나 연결되어 있다.

LinkedList는 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있다고 보면 된다.

[https://lh4.googleusercontent.com/cWFQD2vsXtCSXgw6N94UQT0nfZUa0SzBs4UfCbJwOImmz6MxUSPeYLRqH8tK6X7cHtrLcl0d7g6LFrb6kXYzuBLekOOA47RBXUH7vekVYvN4unKJvzSDPL81G2xRF3NBAQ](https://lh4.googleusercontent.com/cWFQD2vsXtCSXgw6N94UQT0nfZUa0SzBs4UfCbJwOImmz6MxUSPeYLRqH8tK6X7cHtrLcl0d7g6LFrb6kXYzuBLekOOA47RBXUH7vekVYvN4unKJvzSDPL81G2xRF3NBAQ)

ArrayList와 같이 데이터의 추가, 삭제시 불필요한 데이터의 복사가 없어 데이터의 추가, 삭제시에 유리한 반면 데이터의 검색시에는 처음부터 노드를 순회해야 한다.

### 정리 : 추가/삭제와 인덱스 조회 시 성능이 각각 다르다.

![https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/1335/2885.png](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/1335/2885.png)

## 연결리스트(LinkedList) 만들기

[Java로 구현하기](%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%E1%86%AF%20%E1%84%85%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3(Linked%20List)%2052144ea6b5c84a7c929468f654a5ab95/Java%E1%84%85%E1%85%A9%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20e9c54a7ceec040b1ac40b3b867b23cd9.md)

## 단방향 연결리스트에서 노드 삭제

### 개요

- 노드 N이 주어지면 이전 노드 prevN을 찾아 prevN.next를 N.next와 같도록 설정하고, 리스트가 양방향일 경우에는 N.next가 가리키는 노드를 갱신하여 N.next.prev가 N.prev와 같도록 설정해야 한다.
- 유의할 점
    - null 포인터 검사를 반드시 진행할 것
    - 필요 시 head와 tail 포인터도 갱신할 것

### 생각해보기

- 어째서 노드 N이 주어지면 이전 노드 prevN를 찾아 prevN.next를 N.next와 같도록 설정해야 하는가?
    - prevN.next를 N.next와 같도록 설정한다는 건 곧 노드 N을 삭제한다는 의미이다.
- 어째서 널 포인터 검사를 반드시 해야 하는가?
    - 
- 필요 시 head와 tail 포인터를 왜 갱신해야 하는가?
    - 

## Runner 기법

### 개요

- Runner(부가 포인터)는 연결리스트 문제에서 많이 활용되는 기법으로 **연결 리스트를 순회할 때 두 개의 포인터를 동시에 사용**하는 것이다.
    - 이 때, 한 포인터가 다른 포인터보다 앞서도록 한다.
    - 앞 선 포인터가 따라오는 포인터보다 항상 지정된 갯수만큼을 앞서도록 할 수도 있고, 따라오는 포인터가 여러 노드를 한 번에 뛰어넘도록 설정할 수도 있다.

### 생각해보기

- 포인터란 무엇인가?
    - 포인터는 변수의 메모리 주소를 담는 변수이다.
    - 변수의 값을 읽거나 변경하는 등, 변수에 적용 가능한 연산은 모두 포인터를 통해 할 수 있다.
- 포인터와 같은 변수의 주소를 담는 변수가 왜 필요한가?
    - 포인터는 동적 메모리 할당, 많은 자료 구조, 그리고 큰 규모의 데이터를 핸들링하는데 필요하다.
- 포인터는 동적 메모리 할당, 큰 규모의 데이터를 핸들링하는데 왜 필요한가?
    - 
- 어째서 두 개의 포인터를 동시에 사용할 때, 한 포인터가 다른 포인터보다 앞서도록 하는가?
    - 
- 어째서 앞선 포인터가 따라오는 포인터보다 항상 지정된 갯수만큼을 앞서도록 하거나, 아니면 따라오는 포인터를 여러 노드를 한 번에 뛰어넘도록 설정하는가?
    - 

## 재귀 문제

### 개요

- 연결리스트 관련 문제 가운데 상당수는 재귀 호출에 의존한다.
- 연결리스트 문제를 푸는데 난항을 겪고 있다면 재귀적 접근법을 생각해야 한다.
    - 하지만 재귀 호출 깊이가 n이 될 경우, 해당 재귀 알고리즘이 적어도 O(n)만큼의 공간을 사용한다는 사실을 기억해야 한다.
- 모든 재귀 알고리즘은 반복적 형태로도 구현될 수 있으나 한층 복잡해질 수 있다.

### 생각해보기

- 재귀 호출이란 무엇인가?
    - 재귀 호출이란 함수 내부에서 자기 자신을 또다시 호출하는 행위를 의미한다.
- 왜 재귀 호출을 하는가?
    - 재귀 호출을 사용하면 복잡한 문제도 매우 간단하게 논리적으로 접근하여 표현할 수 있다.
- 어째서 재귀 호출을 사용하면 복잡한 문제도 매우 간단하게 논리적으로 접근하여 표현할 수 있는가?
    - 예를 들면, 다음과 같이 1부터 n까지의 합을 계산하는 함수를 재귀 호출로 구현한다 치자.

    ```java
    int sum(int n){
    	if (n == 1){         // n이 1이면, 그냥 1을 반환함.
    		return 1;
    	}

    	return n + sum(n-1); // n이 1이 아니면, n을 1부터 (n-1)까지의 합과 더한 값을 반환함.
    }
    ```

- 왜 연결리스트 관련 문제 가운데 상당수는 재귀 호출에 의존하는가?
    - 연결 리스트는 차례로 연결된 노드를 표현해주는 자료구조인데, 이는 재귀 호출로 구현이 가능하다.
- 연결리스트 관련 문제는 재귀 호출로 어떻게 구현하는가?
    - 예를 들어, 다음 코드는 C언어로 연결 리스트를 재귀 호출로서 구현한 것이다.

    ```c
    void print_list2(node_t *from){
    	if (from == NULL) return;

    	printf("%d ", from-key);
      print_list2(from->next);
    }
    ```

    - 연결리스트에서 전체 리스트에 속한 노드와 노드 간의 연결은 반복되므로 재귀 호출은 노드와 노드간의 연결을 반복적으로 구현할 수 있다.
- 왜 재귀 호출 깊이가 n이 될 경우, 해당 재귀 알고리즘이 적어도 O(n)만큼의 공간을 사용하는가?
    - 
- 왜 모든 재귀 알고리즘은 반복적 형태로도 구현될 수 있는가?
    - 재귀 호출이란 본질적으로 특정한 함수의 실행이 반복되는 것이다. 따라서 재귀 알고리즘은 for문이나 while문과 같은 반복적 형태로도 구현될 수 있다.
- 왜 모든 재귀 알고리즘은 반복적 형태로 구현하면 한층 복잡해질 수 있는가?
    -