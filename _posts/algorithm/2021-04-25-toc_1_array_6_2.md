---
title: "해시 충돌(Hash Collision)"
excerpt: "해시 충돌(Hash Collision)"

categories:
  - IT-Note
tags:
  - 자료구조, 배열, 구조, 해시 충돌
last_modified_at: 2021-04-25T22:44:37
---

## 참조

- 블로그

    [https://yjshin.tistory.com/entry/암호학-해시-함수-작성-중](https://yjshin.tistory.com/entry/%EC%95%94%ED%98%B8%ED%95%99-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98-%EC%9E%91%EC%84%B1-%EC%A4%91)

- 개념

    [비둘기집의 원리](https://namu.wiki/w/%EB%B9%84%EB%91%98%EA%B8%B0%20%EC%A7%91%EC%9D%98%20%EC%9B%90%EB%A6%AC)

## 개요

- 하나의 원 데이터는 하나의 해시값만 가지지만, 하나의 해시값을 만들어낼 수 있는 원본 데이터는 매우 많다. 그 때문에 해시값만 가지고는 아무리 용을 써도 이미 뭉개진 원문을 복원해내는 것은 불가능하다. 따라서 비밀번호, 전자서명, 전자투표, 전자상거래와 같은 민감한 입력의 무결성을 검증할 때 사용된다.
- 따라서 어떤 해시 함수에서 해시 충돌이 일어나기 쉽다는 것은 보안 분야에서는 매우 민감한 문제에 해당한다. 데이터의 무결성과 직접적인 연관이 있기 때문이다.
- 현재까지 개발된 거의 모든 해시 함수는 해시 충돌의 문제가 확인된 상태이다. SHA-1과 SHA-256, SHA-512는 해시 충돌의 가능성이 이론적으로 제시되었다. 2014년 기준으로 문제가 없는 해시 표준으로는 SHA-3가 유일하다.

## 예제

- 0 ~ 10000까지 데이터를 담을 수 있는 리스트를 생성하고, **'tistory'란 단어**에 **해시 함수**를 적용하여 **'2642'란 색인**이 생성되면 **리스트 2642번 색인에 'tistory'를 저장**하는 방식이다.
- 해시 함수는 언제나 동일한 해시 값을 반환하기 때문에 'tistory'를 입력하면 항상 2642란 색인이 나오므로 굳이 정렬하지 않고도 바로 찾을 수 있게 된다.
- 이후 나중에 입력된 **'blog' 단어**를 **해시 함수**에 넣었더니 **'2642'란 색인**으로 나온다면 **'tistory'와 동일한 색인**을 가지게 되는 문제가 발생한다.

## 해시 충돌 해결법

### **분리 연결법(Separate Chaining)**

- 한 버킷당 들어갈 수 있는 엔트리의 수에 제한을 두지 않는 방법으로 모든 자료를 해시테이블에 담는다.
    - 해당 버킷에 데이터가 이미 있다면 체인처럼 노드를 추가하여 다음 노드를 가리키는 방식으로 구현한다.

◇ 단점 : 메모리 문제를 야기할 수 있다.

- Linked List를 이용하는 방식이다. 각 index에 데이타를 저장하는 Linked list에 대한 포인터를 가지는 방식.

![https://blog.kakaocdn.net/dn/yfpMV/btqz3nn7V0C/po81QqppwYl3AhL79IYBVk/img.png](https://blog.kakaocdn.net/dn/yfpMV/btqz3nn7V0C/po81QqppwYl3AhL79IYBVk/img.png)

분리 연결법(sepaate chaining)

- 만약에 동일 index로 인해서 충돌이 발생하면 그 index가 가리키고 있는 Linked list에 노드를 추가하여 값을 추가한다.
- 데이타 추출은 key에 대한 index를 구한 후, index가 가리키고 있는 Linked list를 선형 검색하여 해당 key에 대한 데이터가 있는지를 검색하여 리턴한다.
- key를 삭제하는 것 역시, key에 대한 index가 가리키고 있는 Linked list에서 그 노드를 삭제하면 된다.

### **개방 주소법(Open Addressing)**

- Chaining 과 달리 한 버킷당 들어갈 수 있는 엔트리가 하나뿐인 해시 테이블이다.
- hash table array의 빈공간을 사용하는 방법이다. (Linked list와 같은 추가적인 메모리 공간 사용 없이)
- 개방 주소법(Open Addressing)의 단점은 삭제가 어렵다는 것이다. 삭제를 했을 경우 충돌에 의해서 뒤로 저장된 데이타는 검색이 안될 수 있다.
- 개방 주소법(Open Addressing) 방식도 여러가지 구현 방식이 있는데, 가장 간단한 Linear probing 방식을 소개한다.

**◆ Linear Probing**

- Linear Probing 방식은 index에 대해서 충돌이 발생했을 때, index 뒤에 있는 버킷 중에 빈 버킷을 찾아서 데이타를 넣는 방식이다.
- 11을 키로 하는 데이타가 해시 함수를 거쳐 1이 키인 데이타와 충돌이 발생했을 경우, Linear Probing 에서는 아래 그림과 같이 충돌이 발생한 index(1) 뒤의 버킷에 빈 버킷이 있는지를 검색한다.

![https://blog.kakaocdn.net/dn/IJM9g/btqz5zm8k0H/Nq4fu17qskFsWm9nkQ27Tk/img.png](https://blog.kakaocdn.net/dn/IJM9g/btqz5zm8k0H/Nq4fu17qskFsWm9nkQ27Tk/img.png)

Linear Probing

- 위 그림처럼 2번 버킷은 이미 index가 2인 값이 들어가 있고, 3번 버킷이 비어있기 때문에 3번 값에 넣는다.
- 검색할 때는, array[1]인 배열을 검색하는데, array[0]은 key가 일치하지 않기 때문에 array[1]을 검색해서 값을 찾는다.

### **리스트 크기 재배열**

- 이렇게 충돌 해결을 한다고 해도 결과적으로 충돌로 인한 성능 저하는 막을 수 없다.
- 그래서 수용률이 일정량을 넘어가게 되는 경우에는 아예 리스트 자체의 크기를 키운 뒤에 재배열을 하는 방법을 사용한다.
- 다만, 이 과정 자체가 상당히 비용이 많이 드는 과정이라서 실시간으로 빠르게 처리해야 되는 환경에서는 무리가 있을 수 있다.

### **해시 테이블 확장 방식**

- 큰 리스트를 하나 더 만들어서 적당한 타이밍에 몇 개씩 점진적으로 옮기다가 다 옮기면 기존의 테이블을 없애 확장하는 방식
- 다만 이 경우에는 메모리를 훨씬 더 많이 사용하게 된다.

### **Consistent Hashing - 해시의 비트수를 늘이는 방법**

- 해시의 비트수를 늘이는 방법도 있다.
- 항목 수가 적을 때에는 짧은(적은 비트 수) 해시와 작은 저장공간을 사용하다가 충돌이 잦아지면 비트수를 1비트 늘이고 저장공간도 2배로 늘인다.
- 그리고 항목을 점진적으로 확장된 공간으로 이전하게 함으로써 충돌을 줄일 수 있다.
- Consistent hashing이라고 하며 분산 데이터베이스에서 데이터의 일관성을 유지하기 위해 사용되고 있다.

### **해시 함수 이용하기**

[해시 함수(Hash Function)의 사본](%E1%84%92%E1%85%A2%E1%84%89%E1%85%B5%20%E1%84%8E%E1%85%AE%E1%86%BC%E1%84%83%E1%85%A9%E1%86%AF(Hash%20Collision)%20611de6b277c543a1b69a2652b670b685/%E1%84%92%E1%85%A2%E1%84%89%E1%85%B5%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE(Hash%20Function)%E1%84%8B%E1%85%B4%20%E1%84%89%E1%85%A1%E1%84%87%E1%85%A9%E1%86%AB%20987e154fab1f4f1ea878640cfe02f1b1.md)

![https://blog.kakaocdn.net/dn/c4Ik2R/btqz4L3rK2B/gkxHIKQ6LgdXZZObQOV8PK/img.png](https://blog.kakaocdn.net/dn/c4Ik2R/btqz4L3rK2B/gkxHIKQ6LgdXZZObQOV8PK/img.png)

- 해시테이블의 크기가 m이라면, 좋은 해시함수는 임의의 키 값을 임의의 해시 값에 매핑할 확률이 1m이 될 것이다.
- 즉, 충돌나지 않고 해시 값을 고르게 만들어내는 해시함수가 좋은 해시함수이다.