---
title: 'Node 모음 (임시저장)'
date: 2021-09-23 21:02:46
category: node
thumbnail: './images/node.png'
draft: false
---


## Node.js
자바스크립트 런타임. http 모듈을 내장하고 있어 `const http = require('http');`로 설치 없이 사용할 수 있다. 해당 코드를 실행하면 http 모듈이 서버 역할을 하는 것이므로 노드가 서버는 아니다.

노드는 ES6를 지원하긴 하지만 require()를 사용한다. 아직 통일이 안됐다.

프론트-import, export / 노드-require()

웹팩이 import, export를 require()로 빌드해준다.

<br />

## 프론트/백엔드가 나뉘는 이유
소규모가 아닌 대규모 앱이라면 하나의 컴퓨터에 프론트 요청 1000건, 백 요청 10건이 올 수가 있다. 메모리가 부족하여 터지는데, `스케일링`을 통해 동일한 환경을 그대로 복사하여 컴퓨터를 두대를 두게 된다. 그러면 자원의 불균형이 일어나는데 프론트엔드는 1000/2되어 500건이 되지만, 백 요청은 10/2로 5건이 된다.

즉, 대규모 프로젝트에서는 각 기능별로 서버를 나누고 특정 기능에 데이터 요청이 많이 왔을 때 유동적으로 대처할 수 있다.

작은 컴퓨터 2대가 큰 컴퓨터 1대보다 싸다!

프론트서버(요청) - 백엔드서버(응답)의 형태로, 요청과 응답은 1:1이다. 특정 시간(30초 정도)이 지나면 브라우저가 자동으로 응답 실패로 처리한다.

여러 데이터가 필요하다면 하나의 요청에 여러 데이터를 객체형태로 응답하는 형태로 구현하거나, 잘게 쪼개서 여러번 요청-응답하거나 해야한다.

<br />

## 익스프레스
내부적으로 http 모듈을 사용하여 서버를 구동시킬 수 있는 것이다.

- `app.use(express.json());` : json 데이터를 req.body에 넣어준다.

- `app.use(express.urlencoded({ extended: true }));` : form으로 넘어올 때 데이터를 req.body에 넣어준다.

이걸 해줘야 비동기 통신 시 파라미터로 넘긴 값을 request의 body에 담아준다. 그렇다면 req.body로 접근할 수 있다.

<br />

## API
API는 보통 JSON형태로 응답한다.

restapi. 그러나 합의하기 나름이다.

| 메소드      | 용도                       |
| ----------- | -------------------------- |
| app.get     | 가져오기                   |
| app.post    | 생성하기                   |
| app.put     | 전체를 수정하기            |
| app.delete  | 제거하기                   |
| app.patch   | 부분을 수정하기            |
| app.options | 가능한지 여부를 판단하기   |
| app.head    | 헤더만 가져오기(헤더/바디) |

axios로 데이터 넘길때도 post, put, patch밖에 없다.

<br/>

## sequelize

<br/>

## passport
여러 이메일 로그인 전략이 있는데 passport passport-local를 사용하여 편하게 개발이 가능하다.

1. 프론트에서 서버로는 cookie만 보낸다(clhxy).
2. 서버가 쿠키파서, 익스프레스 세션으로 쿠키 검사 후 id: 1 발견
3. id: 1이 deserializeUser에 들어감
4. req.user로 사용자 정보가 들어감
5. 요청 보낼때마다 deserializeUser가 실행됨(db 요청 1번씩 실행)
6. 실무에서는 deserializeUser 결과물 캐싱

- 1번, 미들웨어 확장 전 : req, res, next를 사용할 수 없다.
  ```js
  const express = require('express');
  const passport = require('passport');
  const router = express.Router();

  // 패스포트 전략으로 검증
  // 1. 서버에러, 2.성공객체, 3.클라이언트에러
  router.post('/login', passport.authenticate('local', (err, user, info) => {
    if(err){
      console.log(err);
      // 이러면 req, res, next를 사용할 수 없다.
      next(error);
    }
  }));
  ```

- 2번, 미들웨어 확장 후 : req, res, next를 사용할 수 있다.
  ```js
  const express = require('express');
  const passport = require('passport');
  const router = express.Router();

  // 패스포트 전략으로 검증
  // 1. 서버에러, 2.성공객체, 3.클라이언트에러
  router.post('/login', (req, res, next) => {
    passport.authenticate('local', (err, user, info) => {
      if (err) {
        console.log(err);
        // 이러면 req, res, next를 사용할 수 없다.
        return next(error);
      }

      if (info) {
        // 허가되지 않음
        return res.status(401).send(info.reason);
      }

      // 패스포트 로그인
      return req.login(user, async (loginErr) => {
        if (loginErr) {
          console.log(loginErr)
          return next(loginErr);
        }
        
        // 최종적으로 응답
        return res.json(user);
      });
    })(req, res, next);
  });
  ```

router, app에 붙는 모든 라이브러리는 미들웨어이다. 위는 익스프레스의 기법으로 해당 패턴만 숙지하자.

<br />

## 상태코드
1:1 요청, 응답이므로 반드시 하나의 응답만 하게 설계하고, 응답 시 `상태 코드`를 먼저, 그 후 `메세지`를 전송한다.

```js

router.post('/', async (req, res, next) => {
  try {
    const exUser = await User.findOne({
      where: {
        email: req.body.email,
      }
    });

    // 중복된 이메일이 있다면 router 종료
    if (exUser) {
      return res.status(403).send('이미 사용중인 아이디입니다.');
    }

    const password = await bcrypt.hash(req.body.password, 13);
    await User.create({
      email: req.body.email,
      nickname: req.body.nickname,
      password
    });
    res.status(201).send('ok'); // status 201, 잘 생성되었다.
  } catch (error) {
    console.error(error);
    next(error);  // status 500
  }
});
```

400번대, 500번대면 서버에서 에러로 본다.

<br/>

## CORS
브라우저 3000에서 브라우저 3001로 보내면 다른 브라우저라고 판단하여 서버가 아니라 브라우저가 차단하는 상황이다. 헤더에 직접 도메인을 허용해버리면 브라우저를 변조하면 CORS 에러가 나지 않는다.

```js
res.setHeader('Access-Control-Allow-Origin', '*');
```

프록시를 사용하여 회피할 수도 있다.

미들웨어 cors로 해결할 수 있다.

```js
app.use(cors({
  origin: '*' // origin: true로 설정하면 * 대신 보낸 곳의 주소가 자동으로 들어간다.
}));
```

단 cors를 기본적으로 허용해버리면 보안 정책을 사용하지 않는 것이므로 잘 유념해야 한다.

<br />

## 로그인 흐름
1. LoginForm에서 {email, password}를 입력받고 로그인 수행
2. redux-saga의 로직 수행
   1. watch 함수 실행
   2. 타입과 액션에 대한 함수
   3. API 통신 실행
3. node-express를 거치면서 req.body로 변경
4. router로 이동, 패스포트 전략(미들웨어)에 의해 인터셉트당함
5. 패스포트 전략에 도달, 인증절차 진행
6. 성공하면 콜백으로 router에 도달, 에러 다시 점검
7. 성공하면 패스포트 로그인 수행
   1. 여기서 문제. 패스포트가 로그인되어도 해당 정보가 프론트와 동일하다는 보장이 없다.
8. 성공하면 백엔드에서 프론트엔드로 응답

이를 처리하기 위해 쿠키/세션을 사용한다.

<br />

## 쿠키/세션
- 설치
  ```sh
  npm i cookie-parser express-session
  ```

```js
const session = require('express-session');
const cookieParser = require('cookie-parser');

// 쿠키 설정
app.use(cookieParser());
// 세션 설정
app.use(session());
app.use(passport.initialize());
app.use(passport.session());
```

로그인을 하면 브라우저와 서버가 `같은 정보`를 가지고 있지 않다. 데이터의 공유가 자동으로 되는 게 아니라 백엔드 서버가 프론트 서버와 브라우저에 전송을 해야 하는 것이다. 이 정보를 통째로 보내주게 되면 해킹에 취약해지는 보안 취약점이 생긴다.

그래서 랜덤한 문자열, 의미를 담지 않은 실제 정보 대신 보내주는 더미 데이터를 보낸다. 이를 쿠키라고 한다. 해당 쿠키 정보로 백엔드 서버에서는 이 쿠키와 연결되어 있고, 안전하게 데이터를 전송할 수 있다. 그 후 임의의 값인 쿠키로 브라우저-프론트엔드, 백엔드 간 데이터 전송이 가능해진다.

서버쪽에서는 통째로 들고 있는 것(세션)과 이를 랜덤한 문자열로 전송(쿠키)하는 것.

세션은 데이터를 통째로 들고 있어 매우 크고 위험하다. 백엔드 서버가 버틸 수 없을 수 있다. 패스포트는 여기에서 필요한 `키`값만 쿠키로 연결해놓고, 이 쿠키로 세션 값을 읽어들이는 형태로 진행된다.

- 패스포트가 쿠키/세션 형태로 데이터를 관리하는 방법
  ```js
  passport.serializeUser((user, done) => {
    done(null, user.id);
  });

  passport.deserializeUser(async (id, done) => {
    try {
      const user = await User.findOne({ where: { id } });
      done(null, user);
    } catch (error) {
      console.error(error);
      done(error);
    }
  });

  local();
  ```
  - 세션에 다 들고 있기 너무 무거워서 user.id만 따로 저장하고, 복원하기 위해서 id를 통해 데이터를 가져오는 것이다.
  - deserializeUser를 거쳐 성공하면 req.body로 데이터를 복원하여 담는다.

<br />

## dotenv
중요한 정보를 하드코딩하기에는 너무 위험부담이 크다.

```sh
npm i dotenv
```

```js
const dotenv = require('dotenv');

dotenv.config();
```
- `process.env.KEY`가 dotenv 파일에 정의한 KEY=VALUE로 매핑된다.

dotenv는 json엔 사용이 불가능하니 js파일로 치환한다.

비밀 키는 반드시 별도로 엄중히 보관한다.

<br />
