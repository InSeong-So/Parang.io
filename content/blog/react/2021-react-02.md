---
title: 'React 모음 (임시저장)'
date: 2021-09-22 11:02:46
category: react
thumbnail: './images/react.png'
draft: false
---


## redux, mobx, context API
여러 페이지에 존재하는 공통적인 데이터(예: 로그인 정보)들이 컴포넌트 분리에 따라 흩어져있다. 부모 컴포넌트를 두어서 데이터를 저장하고, 자식 컴포넌트로 할당해준다. 매번 자식-부모-자식 컴포넌트 간 데이터 전송이 너무 번거로워서 중앙 집중형 저장소를 두고 컴포넌트가 가져다 사용할 수 있게 제어

context API, redux, mobx, GraphQL(Apollo)

초보 탈출 후 생산성을 위해 - mobx, 앱이 작다면 가벼운 context API

redux는 매우 간단하여 에러가 나도 잘 해결이 된다. 안정적이지만 코드량이 많아진다.

mobx는 코드량이 엄청 줄지만 트랙킹(추적)이 힘들다.

context API vs redux/mobx 의 가장 큰 차이점은 비동기를 지원하기 쉽냐 어렵냐

비동기는 실패에 대비해야 하는데, 3단계(요청, 성공, 실패)를 context API로 구현한다면 전부 직접 구현해야한다.
- 보통 useEffect에서 많은 요청을 보낸다. 컴포넌트는 화면에만 집중해야 하는데 데이터까지 다루게 되면 책임이 너무 많아지고 의도치 않은 코드중복이 발생한다.
- 데이터 요청은 별도의 모듈, 라이브러리가 담당하고 컴포넌트는 최대한 화면만 집중한다.
- 물론 context API로 분리 구현할 수 있지만 결국 redux, mobx처럼 나오므로 비동기 통신이 많아지면 편하게 redux, mobx를 사용하는게 좋을것같다.

redux는 reducer를 적절히 쪼개서 중앙 집중형 저장소도 분리가 가능한 시스템이다.


<br />

## redux?
redux는 reduce에서 이름을 따왔다. 데이터 중앙 저장소가 있다고 치면 각 컴포넌트가 필요로 할 때 꺼내 쓸 수 있다. 데이터 조회하기만 하는 게 아니라 수정, 추가, 삭제도 할 수 있다.

redux에서는 데이터를 바꾸려면 action이라는 걸 필수적으로 만들어줘야 한다. action을 통해 조회해온 데이터를 변경하고, action을 dispatch해주면 reducer라는 기능을 타게 되는데 보통은 swtich문으로 구성해서 reducer를 실행한다. 즉 reducer에 작성한 의도대로 저장소의 상태(state)가 변경(반영)되는 것이다.

app에 대한 전체 상태를 객체로 표현하고, 이를 바꾸고 싶을 때마다 action을 하나씩 만든다. 생성한 action을 dispath해주면 개발자가 직접 reducer를 구현해서 반영하는 것이다.

따라서 코드량이 매우 많아진다. redux를 사용하면 action이 정렬어 출력되므로 데이터가 잘못되어 에러가 나는 부분을 쉽게 찾을 수 있다. 또 백트래킹(역추적)이 가능하다.

redux를 사용하는 주 목적 중 하나가 history를 관리하는 것이므로 새로운 객체를 생성해서 교체해주는 형태로 기능이 구현된다.

- 1번
  ```js
  {
    ...state,
    name: action.data,
  }
  ```

- 2번
  ```js
  // 2
  {
    name: action.data,
    age: 16,
    password: 1234
  }
  ```

1번처럼 `...` 연산자(비구조화 할당)를 사용하면 해당 객체의 프로퍼티가 참조된다. 2번처럼 사용하면 action 하나 실행할 때마다 새로운 객체를 생성하므로 메모리 성능을 저하시킨다. 즉, 변경된 부분만 변경시키고 참조 관계인 프로퍼티는 그대로 유지하는 방식을 1번처럼 구현하는 것이다. 즉, 변경되지 않은 프로퍼티는 재사용, 변경된 프로퍼티만 추가적으로 기입하여 사용하는 것이다.

개발모드일 때는 history를 계속 가지고 있으므로 메모리 관리를 하지 않으나 배포(운영)모드일 때는 history를 제거하므로 메모리 관리가 진행된다.

### reducer 직접 구현
```js
// 루트 경로/reducer/index.js

const initialState = {
  name: 'inseong-so',
  age: 16,
  password: 'test'
}

const changeName = {
  type: 'CHANGE_NAME',
  data: 'parang',
}

// (이전 상태, action) > 다음 상태
const rootReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'CHANGE_NAME':
      return {
        ...state,
        name: action.data
      }
  }
}

export default rootReducer
```

만약 변경하는 action이 많다면 아래와 같이 코드가 길어진다.

> action의 이름은 상수로 빼는 것이 편하다.

> 또는 동적으로 변경되게 만들어도 된다.

```js
const changeName1 = {
  type: 'CHANGE_NAME',
  data: 'parang1',
}

const changeName2 = {
  type: 'CHANGE_NAME',
  data: 'parang2',
}

const changeName = {
  type: 'CHANGE_NAME',
  data: 'parang3',
}
```

당연히 reducer를 처리하는 함수에도 swtich의 case문이 계속 증가할 것이고, 중복된 내용의 코드가 계속 작성되어 코드 량이 많아진다. 매번 action을 `직접 작성하는 게 아니라` 동적으로 action을 생성해주는 action creater를 만든다.

```js
const changeName = (data) => {
  return {
    type: 'CHANGE_NAME',
    data,
  }
}

changeName('parangparangparang');
// 실제 dispatch 하기
store.dispatch(changeName('hyuparang'));
```

action creater 외에 비동기 action creater가 존재하는데, 이는 redux saga 내용이다. action 하나 만들면 dispatch하여 reducer에 따라 다음 상태가 나오고, 이전상태와 다음상태를 비교하여 변경된 내용이 있다면 이를 반영하며 다른 컴포넌트에 상태가 변경되었다는 알림이 간다.

reduce의 기초 상태값은 초기 애플리케이션의 공통 데이터 상태값을 작성해두는게 좋다.

```js
const initialState = {
  user: {
    isLoggedIn: false,
    user: null,
    signUpData: {},
    loginData: {},
  },
  post: {
    mainPosts: [],
  }
}

// action creater
export const loginAction = (data) => {
  return {
    type: 'LOG_IN',
    data,
  }
}

const rootReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'LOG_IN':
      return {
        ...state,
        user: {
          ...state.user,
          isLoggedIn: true,
        }
      }
  }
}
```

불변성 때문에 코드가 꽤 지저분(복잡)해 보이지만... 어쩔 수 없다.

react-redux는 react와 redux를 연결해주는 라이브러리이다. 기존 코드와 비교해보자.

- 부모 컴포넌트 redux 적용 전
  ```js
  import { useState } from 'react';

  const [isLogIn, setIsLogIn] = useState('')
  //...
  return (
    // ...
    {isLogIn ? <UserProfile setIsLogIn={setIsLogIn}/> : <LoginForm setIsLogIn={setIsLogIn}/>}
    // ...
  )
  ```

- 부모 컴포넌트 redux 적용 후
  ```js
  import { useSelector } from 'react-redux';

  const isLoggedIn = useSelector((state) => state.user.isLoggedIn);
  //...
  return (
    // ...
    {isLogIn ? <UserProfile /> : <LoginForm />}
    // ...
  )
  ```

isLoggedIn이 변경되면 해당 컴포넌트가 리렌더링된다. 따라서 더 이상 props로 데이터를 넘겨주지 않아도 된다. 이유는? 데이터가 흩어져 있지 않고 중앙 집중형 저장소로 처리하기 때문이다.

redux를 사용하면 useState를 사용할 일이 많이 감소한다.

- 자식 컴포넌트 redux 적용 전
  ```js
  import { useState } from 'react';

  const LoginForm = ({ setIsLoggedIn }) => {

    const onSubmitForm = useCallback(() => {
      console.log(id, password);
      dispatch(loginAction());
    }, [id, password]);

    return (
      // ...
    )
  }
  ```

- 자식 컴포넌트 redux 적용 후
  ```js
  import { useDispatch } from 'react-redux';
  import { loginAction } from '../reducer';

  const LoginForm = () => {
    const dispath = useDispatch();

    const onSubmitForm = useCallback(() => {
      console.log(id, password);
      dispatch(loginAction(id, password));
    }, [id, password]);

    return (
      // ...
    )
  };
  ```

<br />

## HYDRATE
redux를 초기화할 때 reducer도 함께 초기화 된다.

Next.js의 redux store는 클라이언트의 redux store는 다르므로, 이를 합쳐줘야 하는 action이 필요한데 이를 담당하는 것이 `HYDRATE`이다.

action으로 정의한 내용이 존재하지 않는다면(action이 아예 넘어오지 않는다면) switch에 걸리는 조건이 없으므로 null이 반환되고 아래와 같은 에러가 발생한다.
- `WrappedApp created new store with withRedux(RootApp) { initialState: undefined, initialStateFromGSPorGSSR: undefined }`

따라서 HYDRATE를 사용하여 처리하고, default case를 결정해주면 된다.
  ```js
  import { HYDRATE } from 'next-redux-wrapper';

  // ...

  const rootReducer = (state, action) => {
    // ...
    switch (action.type) {
      case HYDRATE:
        return { ...state, ...action.payload };
      default:
        return state;
    //...
      }
  });

  export default rootReducer;
  ```

### 생긴 이유?
getInitailProps가 거의 사용되지 않고 getStaticProps, getServerSideProps 두 개로 분리되어 기존 SSR과 완전히 달라졌기 때문에 생겼다.

<br />

## 미들웨어
redux-devtools-extenstion을 설치했다. 개발용일 때는 개발툴을 허용하고, 운영일때는 허용하면 안된다.

```js
const configureStore = (context) => {
  const middlewares = [];
  const enhancer = process.env.NODE_ENV === 'production'
    ? compose(applyMiddleware(...middlewares))
    : composeWithDevTools(
      applyMiddleware(...middlewares),
    );
  const store = createStore(reducer, enhancer);
  return store;
};
```

이유는 히스토리 로그를 남기므로 메모리가 과하게 소비되고, 내역도 상세히 볼 수 있으므로 분리하는 것이다.

운영에서도 redux-saga, redux-thunk 등을 사용하면 `compose`에, 개발에서 히스토리를 관리하고 디버깅을 하고 싶다면 `composeWithDevTools`에 배열을 구조분해할당한 형태로 넣어주면 된다.

<br />

## reducer 분리
redux에서 제공하는 combineReducers를 사용하여 각 기능별로 reducer를 분리하여 작성하고, 합친다.

```js
import { HYDRATE } from 'next-redux-wrapper'
import { combineReducers } from 'redux'
import user from './user'
import post from './post'


const initialState = {
  user: {

  },
  post: {

  }
}

const rootReducer = combineReducers({
  index: (state = {}, action) => {
    switch (action.type) {
      case HYDRATE:
        return {
          ...state, ...action.payload
        }
      default:
        return state
    };
  },
  user,
  post,
});
```

1. SSR에 필요한 HYDRATE를 위한 index reducer를 만든다.
2. 쪼갠 user, post reducer를 combineReducers로 호출하여 합친다.
  - 함수를 합치는 일은 일반 객체를 합치는 것보다 번거롭고 복잡하므로, combineReducers를 사용해야 한다.

<br />

## SSR 적용 시 필요한 설정
styled-component로 적용한 스타일이 컴포넌트에 적용되지 않는데... 그 이유는 아래와 같다.
1. SSR일때는 프론트 서버에서 HTML과 데이터를 합쳐서 그려준다.
2. 이 때 styled-component는 아직 SSR에서 설정을 안했기 때문에 문제가 발생한다.

즉, 서버 쪽에서는 styled-component가 적용이 안된 상태고, 프론트 서버에서는 적용이 된 상태라 페이지를 이동하면 적용되는 모습을 볼 수 있다.

<br />

## Sequlize 관련
다른 정보와 합쳐지는, 즉 데이터베이스의 엔티티 간 관계가 있는 컬럼이나 테이블, 객체의 이름은 파스칼 케이스로, 그 외에는 카멜케이스로 작성하는 것이 좋다. 시퀄라이즈에서도 그렇게 반환을 해주니까.

물론, 시퀄라이즈는 설정으로 변경 가능하다.

<br />

## useState의 초기값
개발에 redux를 사용하기 시작하면 reducer에 초기값(inistialState)을 정의하여 사용하면 되며, 운영으로 전환 때는 실 데이터로 갈아끼우면 된다.

<br />

## 객체의 앞에 추가하기
```js
{
  // ...
  return {
    ...state,
    mainPosts: [dummyPost, ...state.mainPosts]
  }
  // ...
}
```

<br />

## redux 개발 순서
1. reducer를 먼저 만든다(데이터 구성).
2. 행위, action을 만든다.
3. 화면은 작성한 데이터나 데이터의 구성에 따라 작성한다.

즉, 초기에 서버 개발자와 redux 구조에 대해 합의를 거치는 것이 좋다.

<br />

## 안티 패턴
1. 인덱스를 키로 사용하면 안된다. 특히 게시글 같이 반복되는 성질이 있다면 더더욱.
   - 반복문이 변경되지 않는다면 괜찮다.
2. 키는 고유한 값이 존재해야 한다.

<br />

## DOM 직접 접근
useRef()를 사용한다.

```js
import React, { useRef } from 'react';

const FileForm = () => {
  const imageInput = useRef();

  const onClickImageUpload= useCallback(() => {
    imageInput.current.click();
  }, [imageInput.current]);

  return (
    //...
    <div>
      <input type="file" multiple hidden ref={imageInput}/>
      <Button onClick={onClickImageUpload}>이미지 업로드</Button>
    </div>
    //...
  )
}
```

<br />

## 컴포넌트 설계 시

배열 안에 jsx를 넣을 때는 반드시 `key`를 붙여줘야 한다.

1. 세세한 기능을 생각하지 않고 기획을 한다.
  - 구현을 신경쓰지 말고 우선 그려본다.
    ```js
    const PostCard = () => {
      return (
        <div>
          <Card>
            <Image />
            <Content />
            <Buttons></Buttons>
          </Card>
          <CommentForm />
          <Comments />
        </div>
      )
    }
    ```

2. 구현한다.

<br />

## PropTypes를 사용하면서 Object를 더 자세하게 규정하기
shape 속성을 이용한다.

- 변경 전
  ```js
  import PropTypes from 'prop-types';

  const PostCard = ({post}) => {};

  PostCard.propTypes = {
    post: PropTypes.object.isRequired,
  }
  ```

- 변경 후
  ```js
  import PropTypes from 'prop-types';

  const PostCard = ({post}) => {};

  PostCard.propTypes = {
    post: PropTypes.shape({
      id: PropTypes.number,
      User: PropTypes.object,
      content: PropTypes.string,
      createdAt: PropTypes.object,
      Comments: PropTypes.arrayOf(PropTypes.object),
      Images: PropTypes.arrayOf(PropTypes.object)
    }).isRequired,
  }
  ```

<br />

## 옵셔널 체이닝 연산자 활용
```js
const id = me && me.id;

// 동일하다.

const id = me?.id;
```

<br/>

## true를 false로, false를 true로
부정연산자의 사용으로 이전 데이터를 기반으로 다음 데이터를 만든다.

```js
//..
const [liked, setLiked] = useState(false);
  const onToggleLike = useCallback(() => {
    setLiked((prev) => !prev);
  }, []);
//..
```

<br />

## img 태그의 alt
시각장애인에게 매우 큰 도움이 되므로 alt태그를 잘 작성하면 좋다.

또한 스크린 리더가 role="presentation"를 읽을 때 `클릭이 가능하지만 클릭할 필요는 없다`고 이해하므로 button, input이 아닌 것들은 같이 넣어주면 좋다.

<br />

## 컴포넌트를 파일이 아닌 디렉토리로 구분하는 방법
폴더를 import하면 기본적으로 해당 폴더의 index.js 파일을 불러들인다.

`components/TestForm.js`와 `components/TestForm/index.js`는 styled-component에 차이를 둔다.

스타일드컴포넌트 때문에 분리하는 것은 아니지만, 스타일링을 별개로 두고 export - import를 통해 깔끔하게 관리할 수 있기 떄문이다.

스타일 뿐만 아니라 기능 자체를 분리할 수도 있다. 이럴 경우 폴더로 분리, 주 파일을 index.js로 만들고 다른 부속적 기능을 쪼갠 뒤 export하면 index.js가 최종 export가 되는 형태의 구조화를 꾀함이다.

재사용도 가능해지므로 매우 편리하다.

시각적으로 보기 좋게 만들고 제일 중요한 코드(로직의 핵심)를 하나에 몰아두고 가독성과 유지보수성을 향상시킨다. 굳이 알 필요 없는 기능들을 바깥으로 분리시키는것이다.

<br />

## react-slick
react에서 잘 나가는 carousel 라이브러리

이미 css를 class로 지정해놓고 있으므로 분석해서 사용해야 한다. 그런데 이 클래스를 어떻게 변경할 것인가?

스타일드 컴포넌트는 이를 덮어쓸 수 있게 지원한다.

```js
import {createGlobalStyle} from 'styled-components';

const Global = createGlobalStyle`
  .slick-slide {
    display: inline-block;
  }
`

return (
  <Global />
  //...
)
```

기본적으로 `styled.div`는 지역 스코프를 갖는다. 글로벌로 선언한 컴포넌트는 전역 스코프를 갖고, 기존에 선언된 클래스들을 덮어씌워 작동한다.

스타일드 컴포넌트를 사용하려면 바벨 설정은 필수이다.

<br />

## 화면을 전체로 채우기
css 속성 중 top, left, right, bottom을 0으로 주면 된다.

```css
.fullOverlay {
  position: fixed;
  z-index: 5000;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}
```

<br />

## 함수는 백틱 2개로 호출할 수 있다.
```js
function test(){};

test``;
```

태그드 템플릿 리터럴이라고 한다.

<br />

## styled-component 작성 시
```js
import styled from 'styled-components';

const Header = styled.header`
  header: 44px;
  background: white;
  position: relative;
  padding: 0;
  text-align: center;

  & h1 {
    margin: 0;
    font-size: 17px;
    color: #333;
    line-height: 44px;
  }

  & button {
    position: absolute;
    right: 0;
    top: 0;
    padding: 15px;
    line-height: 14px;
    cursor: pointer;
  }
`;
```
```html
<Header>
  <h1>상세 이미지</h1>
  <button onClick={onClose}>X</button>
</Header>
```
- 스타일 컴포넌트 하위에 있는 태그를 자식 선택자로 지정하여 스타일을 줄 수 있다. 최소화하는 것을 권장한다.

<br />

## transform 에러
브라우저의 유명한 버그로 transform이 선언된 태그 하위에 position: fixed가 선언된 태그가 존재하면 원하지 않은 형태로 css가 출력될 수 있다.

그럴 경우 상단 태그의 css에 `transform: none !important;`를 적용한다.

<br />

## middleware?
> 특정 라이브러리의 기능을 추가하거나 향상시켜주는 체계

redux-thunk는 redux의 미들웨어로써 redux의 기능을 개선한다. redux가 비동기 action을 dispatch 할 수 있게 해준다. redux-saga를 더 많이 사용하지만 같이 알아본다.

redux-thunk는 `지연된 함수`이다.

```js
const INCREMENT_COUNTER = 'INCREMENT_COUNTER';

// sync action creater
function increment() {
  return {
    type: INCREMENT_COUNTER,
  };
}

// async action creater
function incrementAsync() {
  return (dispatch) => {
    setTimeout(() => {
      // Yay! Can invoke sync or async actions with `dispatch`
      dispatch(increment());
    }, 1000);
  };
}
```
- 원래 redux는 위로 밖에 안되지만, redux-thunk를 사용하게 되면 비동기 action 크리에이터가 가능해져서 dispatch를 여러번 할 수 있게 된다. 하나의 비동기 action 안에 여러 개의 동기 action을 넣을 수도 있다. 즉, 원래의 redux 기능을 확장할 수 있게 된 것이다.

```js
function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) => (next) => (action) => {
    if (typeof action === 'function') {
      return action(dispatch, getState, extraArgument);
    }

    return next(action);
  };
}

const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

export default thunk;
```

dispatch를 한 번에 묶어서 실행할 수 있게 해주는 라이브러리가 redux-thunk이다. 고차 함수이면서 3단 함수로 되어 있다.

예를 들어 액션이 디스패치되는 것을 로깅하는 미들웨어가 있다 치자.
  ```js
  const loggerMiddleware = ({ dispatch, getState }) => (next) => (action) => {
    console.log(action);
    return next(action);
  };
  ```
  1. 미들웨어는 항상 화살표 3개, 3단 고차 함수로 구성하면 된다.
  2. thunk에서는 액션을 function으로 둘 수 있으며 function인 경우, 이는 지연함수이기 때문에 나중에 실행되게 해줄 수 있다.
  3. 인자로 받은 dispatch, getState, next 등을 사용하여 조작할 수 있다.

왜 필요할까?

이유는 백엔드 서버와의 통신 때문이다. 대부분의 요청은 비동기로 이루어진다. 동기로 진행되면 사용자 입장에서는 마치 멈춰있는 것처럼 보일 수 있다.

login()을 실행했다고 로그인이 되는 것은 아니다. 기본적으로 아래와 같은 세 부분으로 나뉜다.
1. login에 대한 request를 보낸다.
2. login에 대한 성공 response를 받는다.
3. login에 대한 실패 response를 받는다.

이에 대한 처리를 위해, 프론트엔드에서는 필연적으로 비동기 통신을 해야하며, 이를 안정화 시켜야 한다.

<br />

## thunk? saga?
redux-thunk는 실제 코드가 10줄 밖에 안된다. 즉, 해주는 게 없이 `한 번에 여러번 dispath`가 가능하게 해주는 것일 뿐이라 나머지는 개발자가 구현해야 한다.

그러나 saga는 delay(몇 초 뒤에 액션이 실행될 것인가) 등을 제공해준다. 클릭을 두 번 했다던가, 이런 사용자 경험에 대한 takelatest라는 기능으로 두번 동시에 들어와도 가장 마지막 것만 요청한다. throttle, Debounce이라는 기능으로 스크롤을 내릴 때 이벤트 리스터 내부에 비동기 요청 시 수백번 request에 해당하는 일(dos공격)을 `1초에 몇 번까지 요청을 허용한다 등으로` 방지할 수 있다.

<br />

## 디바운스(Debounce)와 스로틀(Throttle)
이 두 가지 방법 모두 DOM 이벤트를 기반으로 실행하는 자바스크립트를 성능상의 이유로 이벤트(event)를 제어(제한)하는 방법이다.

웹/앱 사용자가 스크롤을 드래깅할 때 수많은 스크롤 이벤트가 발생하는데 매번 스크롤 이벤트에 대한 콜백(callback)이 발생하게되면 메모리에 치명적인 리소스 손실이 일어난다.
수많은 이벤트의 실행으로 메모리나 성능 문제가 발생하니 필연적으로 사용자들이 불편해 하는 것이다.

기존에는 스크롤 이벤트 외부에 timeout을 두어 이벤트가 남용되는 현상을 방지했으나 최근에는 스로틀과 디바운스로 이를 해결하고 있다. 간단히 말해서 제약을 걸어 이벤트를 최소 횟수로 실행하는 것이다.

### 디바운스
이벤트를 그룹화(순차 호출이 아니어도 가능)해서 특정시간 동안 하나의 이벤트만 발생시킨다.

엘리베이터를 생각해보자. 문이 닫히는데 다른 사람이 타려면? 위, 아래로 이동하지 않아 문이 다시 열린다. 그와 동시에 다른 층의 사람이 엘레베이터를 호출하면 이동이 된다. 엘리베이터의 층간 이동이 지연되면서도 기능 구현이 최적화 되는 셈이다.

### 스로틀
이벤트를 일정한 주기마다 발생시킨다. 

<br />

## generator
아래 코드를 실행해보자.

```js
const gen = function*() {}

gen();      // gen {<suspended>}
gen.next(); // {value: undefined, done: true}
```

generator는 그 자체를 실행해서 되는게 아니라, next()를 붙여야 안에 있는 내용이 실행이 된다.

```js
const gen = function* () {
  console.log(1);
  yield;
  console.log(2);
  yield;
  console.log(3);
  yield 4;
}

const generator = gen();

generator.next()  // 1
generator.next()  // 2
generator.next()  // 3
generator.next()  // {value: 4, done: false}
```

`yield` 까지 진행하고 멈춘다. 그렇다는 것은 중단점이 있는 함수인 것이다. done이 true가 될 때까지 next() 함수로 호출할 수 있다.

일반 함수는 함수를 실행하다가 취소할 수 없지만, yield 함수는 가능하다. next()를 호출하지 않으면 된다.

그런데 saga는 절대 멈추지 않는 generator가 존재한다. 아래를 보자. 아래의 코드는 금기 시 되는 코드이다.

```js
const gen = function*(){
  let index = 0;
  while (true){
    yield ++index;
  }
}

const generator = gen();

generator.next(); // {value: 1, done: false}
generator.next(); // {value: 2, done: false}
generator.next(); // {value: 3, done: false}
generator.next(); // {value: 4, done: false}
```

어떤가? while문을 yield문으로 종단점을 구현해 무한이면서 유한한 함수가 되었다. 이러한 성질을 이용해 `이벤트 리스너` 같은 기능을 할 수 있다. 특정 이벤트 때 next()를 하게 되면 yield 부분을 실행하게 하는 것이다.

<br />

## saga 사용
generator를 사용한다.

```js
import { all, fork, take } from 'redux-saga/effects';

function logInAPI() {
  return axios.post('/api/login');
}

function* logIn() {
  try {
    const result = yield call(logInAPI);
    yield pust({
      type: 'LOG_IN_SUCCESS',
      data: result.data
    });
  } catch (err) {
    yield put({
      type: 'LOG_IN_FAILURE',
      data: err.response.data
    });
  }
}

function* watchLogIn() {
  yield take('LOG_IN_REQUEST', logIn);
}

function* watchLogOut() {
  yield take('LOG_OUT_REQUEST');
}

function* watchAddPost() {
  yield take('ADD_POST_REQUEST');
}

export default function* rootSaga() {
  yield all([
    fork(watchLogIn),
    fork(watchLogOut),
    fork(watchAddPost),
  ]);
}
```

이런 기능을 redux-saga의 effect라고 부른다. 루트 사가를 하나 만들고 만들고 싶은 비동기 액션을 하나씩 넣어준다. 보통은 `all` 배열의 하위에 있는 것들은 `한 번에` 실행한다. `fork`나 `call`은 함수를 실행한다는 것이다. 나중에 call이 나오지만 fork와 call은 다르다. 그러나 기능은 비슷하게 대체된다.

take는 첫 번째 인수로 넘겨지는 액션이 `실행될 때까지 기다리겠다`는 함수이다. 두 번째 인수는 해당 액션이 실행됨을 감지하고 실행되는 함수이며, 해당 함수에서 `일반 함수`를 호출하여 통신을 진행한다.

thunk와 비교하면 비동기 액션 크리에이터이며, `직접 실행되는 게 아니라 이벤트 리스너처럼 실행`된다. 로그인 함수가 실행되면, 후속 로그인 함수가 실행되는 형식이다. saga의 effect 앞에는 반드시 yield를 선언하여 사용한다. put은 dispatch이다. redux는 action이 너무 많이 나오니까 최소화하는 것이 좋다.

call은 비동기 함수 호출, fork는 동기 함수 호출이다. fork는 요청 보내버리고 다음 기능을 실행(non-bloking)하므로 통신 결과를 받아서 사용해야 한다면 call을 사용해야 한다. 아래처럼 진행되는 것이다.
```js
const result = yield call(logInAPI);
axios.post('/api/login').then(() => {}).catch(() => {});

const result = yield fork(logInAPI);
axios.post('/api/login');
```

yield는 await이랑 비슷하다. call은 await를, fork는 그냥 실행하는 것이다.

all, fork, call, take, put, delay, debounce, throttle, takelatest, takeevery, takemaybe 등이 있다. 각각의 사용법, 패턴, 원리를 알아두자.

login 할 때, 실제 데이터를 전송해야 하는데 watchLogin()의 액션을 보자. logIn에 action에 대한 데이터가 자동으로 들어가는 흐름을 이해하면 좋다. 일반적으로 함수 호출 시
```js
logInAPI(action.data);
```
이지만 call을 호출할 때는 이를 펼쳐줘야 한다.
```js
call(logInAPI, action.data);


function logInAPI(data, a, b, c){
  //...
}

call(logInAPI, action.data, 'a','b','c');
```

그냥 call이라는 effect 함수의 특성이다. effect 앞에 yield를 붙여주는 이유는?

saga는 테스트에서 매우 편리하다. 동작이 제대로 되는지에 대한 보장이 되어야 하는데, 이를 해소하려면 테스트코드를 작성해야 한다. 그 때 generator와 yield를 사용하면 매우 편리하다.

### 이벤트 리스너?
```js
function* watchLogIn() {
  yield take('LOG_IN_REQUEST', logIn);
}

function* watchLogOut() {
  yield take('LOG_OUT_REQUEST', logOut);
}

function* watchAddPost() {
  yield take('ADD_POST_REQUEST', addPost);
}
```

이런 부분은 이벤트 리스너 같은 역할을 하는데, yield take의 치명적인 단점은 1회용이라는 점이다. 한 번 LOG_IN_REQUEST를 하면 실행되겠지만, 단 한 번밖에 안 받으므로 그 다음 이벤트에는 해당 이벤트 리스너가 사라져버린다.

즉, 로그인, 로그아웃, 게시글을 한 번 밖에 못하는 것이다. 이를 무한하게 실행하는 방법은 상술했다.

```js
function* watchAddPost() {
  while(true){
    yield take('ADD_POST_REQUEST', addPost);
  }
}
```

하지만 직관적이지 않다. 그래서 나온 것이 takeEvery이다. while take는 동기적으로 동작하지만 takeEvery는 비동기적으로 동작한다.

```js
function* watchAddPost() {
  while(true){
    yield takeEvery('ADD_POST_REQUEST', addPost);
  }
}
```

만약 클릭 실수로 두 번 클릭됐다면? takeEvery는 두 번 실행되게 된다. 이에 대한 해결책으로 takeLatest를 사용할 수 있다. takeLatest는 마지막 것만 알아서 실행한다. 반대로 첫 번째 것만 하고 싶다면 takeLeading을 쓴다.

takeLatest가 마지막 것만 실행한다는 기준은 이미 완료된 건을 제외하고 다음걸 실행하는 것이다. 동시에 로딩 중인 것에서만 마지막 거를 사용한다고 판단한다. 허나 이건 프론트 서버를 기준으로 하는 것이다. 응답을 취소하는 것이지 요청을 취소하는게 아니다. 프론트 서버에서 백엔드 서버로 요청을 2회 보내지만 백엔드 서버에서 프론트 서버에서 응답을 2회 보내는 것 중 마지막 응답만 받는 것이다. 글을 등록하는 이벤트를 더블클릭했다면 최초에서는 하나로만 보이지만 새로고침하면 게시글이 두개가 될 수 있다.

```js
function* watchAddPost() {
  yield throttle('ADD_POST_REQUEST', addPost, 2000);
}
```

스로틀을 사용하면 맨 마지막 인수의 값에 대한 기간에는 요청을 1회로 제한한다. 일반적으로 프론트에서 takeLatest를 사용한다. 백엔드 서버에서 데이터 검증을 하기 때문에. 그러나 데이터가 너무 많거나 ddos공격이 우려될 때는 다른 이펙트를 사용한다.